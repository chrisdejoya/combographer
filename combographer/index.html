<script>
    const comboOutput = document.getElementById('combo-output');
    const settingsToggle = document.getElementById('settings-toggle');
    const settingsPanel = document.getElementById('settings-panel');
    const controllerStatus = document.getElementById('controller-status');
    const gameProfileSelect = document.getElementById('game-profile');
    const buttonMappingContainer = document.getElementById('button-mapping-container');
    const fontSizeInput = document.getElementById('font-size');
    const fontColorInput = document.getElementById('font-color');
    const clearDelayInput = document.getElementById('clear-delay');
    const clearButton = document.getElementById('clear-button');

    let gamepad = null;
    let prevButtons = [];
    let inputHistory = [];
    let comboString = "";
    let clearTimer = null;

    const DEADZONE = 0.5;
    const BACKSPACE_DELAY = 200; // ms between deletes
    let lastBackspaceTime = 0;

    // ✅ Arrow notation instead of numpad
    const DIR_MAP = {
        '1': '↙', '2': '↓', '3': '↘',
        '4': '←', '5': '•', '6': '→',
        '7': '↖', '8': '↑', '9': '↗'
    };

    const PROFILES = {
        '2xko': { 0: 'T', 1: 'H', 2: 'L',  3: 'M', 4: 'P', 5: 'D', 6: 'S1', 7: 'S2', 10: 'Th', 11: 'Ta' },
        'street-fighter': { 0: 'LP', 1: 'MP', 2: 'LK', 3: 'MK', 4: 'HP', 5: 'HK', 6: 'P', 7: 'K' },
        'tekken': { 0: '1', 1: '2', 2: '3', 3: '4' },
        'gg-dbfz': { 0: 'P', 1: 'K', 2: 'S', 3: 'HS', 4: 'D' },
        'custom': {}
    };
    let currentMapping = PROFILES['2xko']; // ✅ default to 2XKO

    const MOTIONS = [
        { name: '↓↘→', pattern: ['2', '3', '6'] },   // quarter circle forward
        { name: '↓↙←', pattern: ['2', '1', '4'] },   // quarter circle back
        { name: '→↓↘', pattern: ['6', '2', '3'] },   // DP motion
        { name: '←↓↙', pattern: ['4', '2', '1'] },
        { name: '←↙↓↘→', pattern: ['4', '1', '2', '3', '6'] }, // half circle fwd
        { name: '→↘↓↙←', pattern: ['6', '3', '2', '1', '4'] }, // half circle back
    ];

    function setupEventListeners() {
        settingsToggle.addEventListener('click', () => {
            settingsPanel.classList.toggle('settings-hidden');
        });

        gameProfileSelect.value = '2xko'; // ✅ select 2XKO by default
        loadProfile('2xko');

        gameProfileSelect.addEventListener('change', (e) => {
            loadProfile(e.target.value);
        });

        fontSizeInput.addEventListener('input', updateAppearance);
        fontColorInput.addEventListener('input', updateAppearance);
        
        clearButton.addEventListener('click', clearCombo);

        window.addEventListener("gamepadconnected", (e) => {
            gamepad = e.gamepad;
            controllerStatus.textContent = `Connected: ${gamepad.id}`;
            controllerStatus.classList.remove('text-red-400');
            controllerStatus.classList.add('text-green-400');
            prevButtons = new Array(gamepad.buttons.length).fill(false);
            createButtonMappingUI(gamepad.buttons.length);
            loadProfile(gameProfileSelect.value);
            gameLoop();
        });

        window.addEventListener("gamepaddisconnected", () => {
            gamepad = null;
            controllerStatus.textContent = "Controller disconnected.";
            controllerStatus.classList.add('text-red-400');
            controllerStatus.classList.remove('text-green-400');
        });
    }
    
    function createButtonMappingUI(buttonCount) {
        buttonMappingContainer.innerHTML = '';
        for (let i = 0; i < buttonCount; i++) {
            const div = document.createElement('div');
            const label = document.createElement('label');
            label.textContent = `Button ${i}`;
            label.className = 'block text-sm font-medium';
            const input = document.createElement('input');
            input.type = 'text';
            input.id = `button-map-${i}`;
            input.dataset.index = i;
            input.className = 'w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-1 mt-1 text-sm';
            input.addEventListener('input', (e) => {
                currentMapping[e.target.dataset.index] = e.target.value;
                if(gameProfileSelect.value !== 'custom') gameProfileSelect.value = 'custom';
            });
            div.appendChild(label);
            div.appendChild(input);
            buttonMappingContainer.appendChild(div);
        }
    }
    
    function loadProfile(profileName) {
        if(profileName !== 'custom'){
            currentMapping = { ...PROFILES[profileName] };
        }
        updateMappingUI();
    }
    
    function updateMappingUI() {
        for (const key in currentMapping) {
            const input = document.getElementById(`button-map-${key}`);
            if (input) {
                input.value = currentMapping[key] || '';
            }
        }
        const allInputs = buttonMappingContainer.querySelectorAll('input');
        allInputs.forEach(input => {
            if (!currentMapping.hasOwnProperty(input.dataset.index)) {
                input.value = '';
            }
        });
    }

    function updateAppearance() {
        comboOutput.style.fontSize = `${fontSizeInput.value}px`;
        comboOutput.style.color = fontColorInput.value;
    }
    
    function clearCombo() {
        comboString = "";
        inputHistory = [];
        comboOutput.textContent = comboString;
    }
    
    function scheduleClear() {
        clearTimeout(clearTimer);
        clearTimer = setTimeout(clearCombo, clearDelayInput.value);
    }

    function getDirection(axes) {
        const [h, v] = axes;
        if (Math.abs(h) < DEADZONE && Math.abs(v) < DEADZONE) return '5';
        if (v > DEADZONE) {
            if (h > DEADZONE) return '3';
            if (h < -DEADZONE) return '1';
            return '2';
        }
        if (v < -DEADZONE) {
            if (h > DEADZONE) return '9';
            if (h < -DEADZONE) return '7';
            return '8';
        }
        if (h > DEADZONE) return '6';
        if (h < -DEADZONE) return '4';
        return '5';
    }

    function getDpadDirection(buttons) {
        const up    = buttons[12]?.pressed;
        const down  = buttons[13]?.pressed;
        const left  = buttons[14]?.pressed;
        const right = buttons[15]?.pressed;

        if (up && left) return '7';
        if (up && right) return '9';
        if (down && left) return '1';
        if (down && right) return '3';
        if (up) return '8';
        if (down) return '2';
        if (left) return '4';
        if (right) return '6';
        return '5';
    }
    
    function processInput() {
        if (!gamepad) return;
    
        let dpadDir = getDpadDirection(gamepad.buttons);
        let stickDir = getDirection(gamepad.axes);
        let currentDirection = (dpadDir !== '5') ? dpadDir : stickDir;

        // detect direction changes
        if (currentDirection !== '5' && inputHistory[inputHistory.length - 1] !== currentDirection) {
            // double-tap detection (forward forward / back back)
            if (inputHistory.length > 0 && inputHistory[inputHistory.length - 1] === currentDirection) {
                comboString += (comboString ? " > " : "") + DIR_MAP[currentDirection] + DIR_MAP[currentDirection];
                comboOutput.textContent = comboString;
            } else {
                inputHistory.push(currentDirection);
                if (inputHistory.length > 10) inputHistory.shift();
            }
        }
    
        let pressedButtons = [];
        gamepad.buttons.forEach((button, i) => {
            if (button.pressed && !prevButtons[i]) {
                // ✅ Backspace with debounce
                if (i === 8) {
                    const now = Date.now();
                    if (now - lastBackspaceTime > BACKSPACE_DELAY) {
                        comboString = comboString.trim().replace(/(>?\s*[^>+\s]+(\+[^>+\s]+)*)$/, "");
                        comboOutput.textContent = comboString;
                        lastBackspaceTime = now;
                    }
                    prevButtons[i] = button.pressed;
                    return;
                }

                if (currentMapping[i]) {
                    pressedButtons.push(currentMapping[i]);
                }
            }
            prevButtons[i] = button.pressed;
        });
        
        if (pressedButtons.length > 0) {
            let motionFound = '';
            for(const motion of MOTIONS) {
                const historyStr = inputHistory.join('');
                const patternStr = motion.pattern.join('');
                if (historyStr.endsWith(patternStr)) {
                    motionFound = motion.name;
                    break;
                }
            }
    
            if (motionFound) {
                comboString += (comboString ? " > " : "") + motionFound;
                inputHistory = [];
            } else if (inputHistory.length > 0 && inputHistory[inputHistory.length - 1] !== '5') {
                comboString += (comboString ? " > " : "") + DIR_MAP[inputHistory[inputHistory.length - 1]];
            }
    
            comboString += (comboString && !comboString.endsWith(" ") ? "+" : "") + pressedButtons.join('+');
            comboOutput.textContent = comboString;
            scheduleClear();
        }
    }
    
    function gameLoop() {
        if (!gamepad) return;

        const freshGamepad = navigator.getGamepads()[gamepad.index];
        if (freshGamepad) {
            gamepad = freshGamepad;
            processInput();
        }
        
        requestAnimationFrame(gameLoop);
    }

    setupEventListeners();
    updateAppearance();
</script>
